const BaseService = require('./BaseService');
const bcrypt = require('bcryptjs');

class UserService extends BaseService {
    constructor() {
        super('users');
    }

    async createUser(userData) {
        // 检查用户名和邮箱是否已存在
        await this.checkUserExists(userData.username, userData.email);
        
        // 加密密码
        const saltRounds = 12;
        const passwordHash = await bcrypt.hash(userData.password, saltRounds);
        
        // 准备用户数据
        const userDataWithHash = {
            username: userData.username,
            email: userData.email,
            password_hash: passwordHash,
            avatar: userData.avatar || null,
            bio: userData.bio || null,
            location: userData.location || null,
            website: userData.website || null,
            cover_image: userData.cover_image || null
        };
        
        return await this.create(userDataWithHash);
    }

    async findByUsername(username) {
        const [rows] = await this.db.execute(
            'SELECT * FROM users WHERE username = ?',
            [username]
        );
        return rows[0] || null;
    }

    async findByEmail(email) {
        const [rows] = await this.db.execute(
            'SELECT * FROM users WHERE email = ?',
            [email]
        );
        return rows[0] || null;
    }

    async checkUserExists(username, email) {
        const existingUser = await this.findByUsername(username);
        if (existingUser) {
            throw new Error('Username already exists');
        }
        
        const existingEmail = await this.findByEmail(email);
        if (existingEmail) {
            throw new Error('Email already in use');
        }
    }

    async validatePassword(plainPassword, hashedPassword) {
        return await bcrypt.compare(plainPassword, hashedPassword);
    }

    async getUserProfile(id) {
        const [rows] = await this.db.execute(
            `SELECT id, username, email, avatar, bio, location, website, 
                    cover_image, posts_count, followers_count, following_count, created_at 
             FROM users WHERE id = ?`,
            [id]
        );
        return rows[0] || null;
    }

    async updateProfile(id, profileData) {
        const allowedFields = [
            'username', 'email', 'avatar', 'bio', 
            'location', 'website', 'cover_image'
        ];
        const updateData = {};
        
        // 只允许更新特定字段
        for (const field of allowedFields) {
            if (profileData[field] !== undefined) {
                updateData[field] = profileData[field];
            }
        }
        
        if (Object.keys(updateData).length === 0) {
            throw new Error('No valid update data provided');
        }
        
        // 如果更新用户名或邮箱，需要检查重复
        if (updateData.username || updateData.email) {
            const currentUser = await this.findById(id);
            if (!currentUser) {
                throw new Error('User not found');
            }
            
            if (updateData.username !== currentUser.username) {
                const existingUser = await this.findByUsername(updateData.username);
                if (existingUser && existingUser.id !== id) {
                    throw new Error('Username already exists');
                }
            }
            
            if (updateData.email !== currentUser.email) {
                const existingEmail = await this.findByEmail(updateData.email);
                if (existingEmail && existingEmail.id !== id) {
                    throw new Error('Email already in use');
                }
            }
        }
        
        return await this.update(id, updateData);
    }

    async updatePostsCount(userId, increment = true) {
        try {
            const operation = increment ? '+' : '-';
            await this.db.execute(
                `UPDATE users SET posts_count = posts_count ${operation} 1 WHERE id = ?`,
                [userId]
            );
        } catch (error) {
            console.error('Failed to update posts count:', error);
        }
    }
}

module.exports = UserService;
